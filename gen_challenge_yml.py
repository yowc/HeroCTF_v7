#!/usr/bin/env python3
import argparse
import json
import logging
import re
import sys
from pathlib import Path
from typing import Dict, List, Optional, Tuple

# --- Configuration ---


class Config:
    """Groups all script constants and configurations."""

    YML_FILE_NAME = "challenge.yml"
    MD_FILE_NAME = "README.md"
    TITLE_PREFIX = "#"
    PARAGRAPH_PREFIX = "###"
    CODE_PREFIX = "```"

    MANDATORY_PARAGRAPHS = {
        "author",
        "category",
        "description",
        "difficulty",
        "write up",
        "flag",
    }
    OPTIONAL_PARAGRAPHS = {"files", "requirements", "tags"}

    VALID_CATEGORIES = {
        "Android",
        "Crypto",
        "Forensics",
        "Misc",
        "Prog",
        "Pwn",
        "Reverse",
        "Steganography",
        "System",
        "Web",
    }
    VALID_DIFFICULTIES = {"Very Easy", "Easy", "Medium", "Hard"}

    # Regex for validating specific markdown sections
    REGEX_FILES = r"^(- \[[^\]]+\]\([^)]+\)\n?)+$"
    REGEX_REQUIREMENTS = r'^(- "[^"\n]+?"\n?)+$'
    REGEX_TAGS = r"^(- [^\n]+\n?)+$"
    REGEX_FLAG = r"^Hero{\S+}$"

    # Template for the generated challenge.yml file
    YML_TEMPLATE = """\
# /!\\ This file is autogenerated. Please do not edit
name: {title}
author: {author}
category: {category}
description: {description}
value: 0
type: dynamic

extra:
    initial: 500
    decay: 200
    minimum: 50

image: null
host: null

flags:
    - {{
        type: "static",
        content: {flag},
        data: "case_insensitive",
    }}

{tags}

{files}

{requirements}
state: visible
version: "0.1"
"""


# --- Custom Exceptions ---


class ScriptError(Exception):
    """Base exception for script-specific errors."""

    pass


class ParsingError(ScriptError):
    """Error during Markdown parsing."""

    pass


class ValidationError(ScriptError):
    """Error during data validation."""

    pass


# --- Core Logic ---


def parse_markdown(md_path: Path) -> Tuple[str, Dict[str, str]]:
    """
    Parses a markdown file to extract the title and content of each paragraph.

    Args:
        md_path: The path to the markdown file.

    Returns:
        A tuple containing the challenge title and a dictionary of paragraphs.

    Raises:
        ParsingError: If the markdown format is invalid (e.g., multiple titles).
    """
    title = None
    paragraphs = {}
    current_paragraph = None
    in_code_block = False

    with md_path.open("r", encoding="utf-8") as f:
        for line in f:
            if line.startswith(Config.CODE_PREFIX):
                in_code_block = not in_code_block
                if current_paragraph:
                    paragraphs[current_paragraph] += line
                continue

            if in_code_block:
                if current_paragraph:
                    paragraphs[current_paragraph] += line
                continue

            if line.startswith(Config.PARAGRAPH_PREFIX):
                current_paragraph = (
                    line.removeprefix(Config.PARAGRAPH_PREFIX).strip().lower()
                )
                if current_paragraph in paragraphs:
                    raise ParsingError(
                        f"Duplicate paragraph found: '{current_paragraph}'"
                    )
                paragraphs[current_paragraph] = ""
            elif line.startswith(Config.TITLE_PREFIX):
                if title is not None:
                    raise ParsingError("Multiple titles found.")
                title = line.removeprefix(Config.TITLE_PREFIX).strip()
            elif current_paragraph:
                paragraphs[current_paragraph] += line

    if not title:
        raise ParsingError("No title found.")

    # Clean up whitespace in paragraph content
    for key, value in paragraphs.items():
        paragraphs[key] = value.strip()

    return title, paragraphs


def validate_paragraphs(paragraphs: Dict[str, str]) -> List[str]:
    """
    Validates that paragraphs meet the required format and content rules.

    Args:
        paragraphs: A dictionary of paragraphs parsed from markdown.

    Returns:
        A list of warning messages. An empty list signifies success.
    """
    warnings = []
    keys = set(paragraphs.keys())

    # Check for missing mandatory paragraphs
    missing = Config.MANDATORY_PARAGRAPHS - keys
    if missing:
        warnings.append(f"Missing mandatory paragraphs: {', '.join(sorted(missing))}")

    """
    # KEEP TITLES FOR WRITEUPS
    # Check for unknown paragraphs
    unknown = keys - (Config.MANDATORY_PARAGRAPHS | Config.OPTIONAL_PARAGRAPHS)
    if unknown:
        warnings.append(f"Unknown paragraphs: {', '.join(sorted(unknown))}")
    """

    # Field-specific content validation
    if (
        "category" in paragraphs
        and paragraphs["category"] not in Config.VALID_CATEGORIES
    ):
        warnings.append(f"Invalid category: '{paragraphs['category']}'")
    if (
        "difficulty" in paragraphs
        and paragraphs["difficulty"] not in Config.VALID_DIFFICULTIES
    ):
        warnings.append(f"Invalid difficulty: '{paragraphs['difficulty']}'")
    if "flag" in paragraphs and not re.fullmatch(Config.REGEX_FLAG, paragraphs["flag"], re.IGNORECASE):
        warnings.append(f"Flag format is incorrect: '{paragraphs['flag']}'")
    if "files" in paragraphs and not re.fullmatch(
        Config.REGEX_FILES, paragraphs["files"], re.MULTILINE
    ):
        warnings.append("Format for 'files' section is invalid.")
    if "requirements" in paragraphs and not re.fullmatch(
        Config.REGEX_REQUIREMENTS, paragraphs["requirements"], re.MULTILINE
    ):
        warnings.append("Format for 'requirements' section is invalid.")
    if "tags" in paragraphs and not re.fullmatch(
        Config.REGEX_TAGS, paragraphs["tags"], re.MULTILINE
    ):
        warnings.append("Format for 'tags' section is invalid.")

    return warnings


def generate_yml_content(title: str, paragraphs: Dict[str, str]) -> str:
    """
    Formats the parsed data and generates the final YAML file content.

    Args:
        title: The challenge title.
        paragraphs: The validated paragraph data.

    Returns:
        The complete string content for the challenge.yml file.
    """
    # Prepare description
    description = paragraphs["description"].replace("\n", "<br>")
    description += f"<br><br>Format: **`{Config.REGEX_FLAG}`**"
    description += f"<br>Author: **{paragraphs['author']}**"

    # Prepare tags - difficulty is always first
    difficulty_tag = paragraphs["difficulty"].lower().replace(" ", "-")
    additional_tags = []

    # Extract tags from paragraphs if present
    if "tags" in paragraphs:
        tag_lines = [
            line.strip() for line in paragraphs["tags"].split("\n") if line.strip()
        ]
        for line in tag_lines:
            if line.startswith("- "):
                tag = line[2:].strip()
                if tag:
                    additional_tags.append(tag.lower())

    # Remove duplicates and sort additional tags, but keep difficulty first
    additional_tags = sorted(set(additional_tags))
    # Remove difficulty from additional tags if it appears there to avoid duplicates
    additional_tags = [tag for tag in additional_tags if tag != difficulty_tag]
    all_tags = [difficulty_tag] + additional_tags

    tags_yml = "tags:\n" + "\n".join(f"    - {tag}" for tag in all_tags)

    # Prepare files
    files_yml = ""
    if "files" in paragraphs:
        file_paths = re.findall(r"\]\(([^)]+)\)", paragraphs["files"])
        files_yml = "files:\n" + "\n".join(f"    - {path}" for path in file_paths)

    # Prepare requirements
    requirements_yml = ""
    if "requirements" in paragraphs:
        req_items = [r.strip() for r in paragraphs["requirements"].split("\n")]
        requirements_yml = "requirements:\n" + "\n".join(
            f"    {item}" for item in req_items
        )

    # Populate template
    content = Config.YML_TEMPLATE.format(
        title=json.dumps(title),
        author=json.dumps(paragraphs["author"]),
        category=json.dumps(paragraphs["category"]),
        description=json.dumps(description),
        flag=json.dumps(paragraphs["flag"]),
        tags=tags_yml,
        files=files_yml,
        requirements=requirements_yml,
    ).strip()

    # Clean up multiple consecutive newlines, but ensure single newline before state
    content = re.sub(r"\n{3,}", "\n\n", content)

    return content


# --- Main Execution ---


def setup_arg_parser() -> argparse.ArgumentParser:
    """Configures and returns the argument parser."""
    parser = argparse.ArgumentParser(
        description="Generate challenge.yml from README.md files."
    )
    parser.add_argument(
        "directory",
        nargs="?",
        help="Challenge or category to process. If empty, processes all challenges.",
    )
    parser.add_argument(
        "-f",
        "--force",
        action="store_true",
        help="Overwrite existing challenge.yml files.",
    )
    parser.add_argument(
        "-v",
        "--validate",
        action="store_true",
        help="Validate README.md files without generating .yml files.",
    )
    parser.add_argument(
        "-q", "--quiet", action="store_true", help="Suppress all informational output."
    )
    return parser


def main():
    """Main script entry point."""
    parser = setup_arg_parser()
    args = parser.parse_args()

    # Configure logging
    log_level = logging.WARNING if args.quiet else logging.INFO
    logging.basicConfig(level=log_level, format="%(message)s", stream=sys.stdout)

    # Validate argument combinations
    if args.validate and args.force:
        logging.error("[x] --validate cannot be used with other options.")
        return 1

    # Determine search paths
    base_path = Path.cwd()
    search_paths = []
    if not args.directory:
        search_paths.extend(
            base_path / category for category in Config.VALID_CATEGORIES
        )
    else:
        search_paths.append(base_path / args.directory)

    # Find all challenge directories to process
    challenge_dirs = []
    for path in search_paths:
        if not path.is_dir():
            logging.warning(f"[!] Path not found or not a directory: {path}")
            continue
        # Check if path is a category or a single challenge dir
        if (path / Config.MD_FILE_NAME).is_file():  # single challenge dir
            challenge_dirs.append(path)
        else:  # category dir
            challenge_dirs.extend(d for d in path.iterdir() if d.is_dir())

    # Process each challenge
    processed_count = 0
    for chall_dir in sorted(challenge_dirs):
        md_path = chall_dir / Config.MD_FILE_NAME
        yml_path = chall_dir / Config.YML_FILE_NAME

        if not md_path.is_file():
            logging.info(f"No README.md file found in {chall_dir}.")
            continue

        logging.info(f"[*] Processing: {chall_dir.relative_to(base_path)}")

        # Decide whether to skip or proceed
        should_skip = yml_path.exists() and not (args.force or args.validate)
        if should_skip:
            continue

        try:
            # 1. Parse
            title, paragraphs = parse_markdown(md_path)

            # 2. Validate
            warnings = validate_paragraphs(paragraphs)
            if warnings:
                for warning in warnings:
                    logging.warning(
                        f"[!] Validation failed for {md_path.parent.name}: {warning}"
                    )
                if not args.validate:
                    continue  # Skip generation if validation fails

            if args.validate:
                logging.info(f"[+] Validation successful for {chall_dir.name}")
                processed_count += 1
                continue

            # 3. Generate & Write
            yml_content = generate_yml_content(title, paragraphs)
            yml_path.write_text(yml_content, encoding="utf-8")
            logging.info(f"[+] Generated: {yml_path.relative_to(base_path)}")
            processed_count += 1

        except ScriptError as e:
            logging.error(f"[x] Error in {chall_dir.name}: {e}")

    logging.info(f"\n[*] Done. Processed {processed_count} challenges.")
    return 0


if __name__ == "__main__":
    sys.exit(main())
